{"ast":null,"code":"/**\n * react-router v7.9.5\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\"use client\";\n\nimport _objectSpread from \"C:/Users/milen/Desktop/PROGRAMMING/QuizMoodle/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { RSCRouterGlobalErrorBoundary, deserializeErrors, getHydrationData, populateRSCRouteModules } from \"./chunk-JG3XND5A.mjs\";\nimport { CRITICAL_CSS_DATA_ATTRIBUTE, ErrorResponseImpl, FrameworkContext, RSCRouterContext, RemixErrorBoundary, RouterProvider, UNSTABLE_TransitionEnabledRouterProvider, createBrowserHistory, createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createContext, createRequestInit, createRouter, decodeViaTurboStream, getPatchRoutesOnNavigationFunction, getSingleFetchDataStrategyImpl, getTurboStreamSingleFetchDataStrategy, hydrationRouteProperties, invariant, isMutationMethod, mapRouteProperties, noActionDefinedError, setIsHydrated, shouldHydrateRouteLoader, singleFetchUrl, stripIndexParam, useFogOFWarDiscovery } from \"./chunk-UIGDSWPH.mjs\";\n\n// lib/dom-export/dom-router-provider.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */React.createElement(RouterProvider, _objectSpread({\n    flushSync: ReactDOM.flushSync\n  }, props));\n}\n\n// lib/dom-export/hydrated-router.tsx\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n      if (importMap !== null && importMap !== void 0 && importMap.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\nfunction createHydratedRouter(_ref) {\n  let {\n    getContext,\n    unstable_instrumentations\n  } = _ref;\n  initSsrInfo();\n  if (!ssrInfo) {\n    throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n  }\n  let localSsrInfo = ssrInfo;\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch(e => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n  let routes = createClientRoutes(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n  let hydrationData = void 0;\n  if (ssrInfo.context.isSpaMode) {\n    var _ssrInfo$manifest$rou;\n    let {\n      loaderData\n    } = ssrInfo.context.state;\n    if ((_ssrInfo$manifest$rou = ssrInfo.manifest.routes.root) !== null && _ssrInfo$manifest$rou !== void 0 && _ssrInfo$manifest$rou.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    var _window$__reactRouter;\n    hydrationData = getHydrationData({\n      state: ssrInfo.context.state,\n      routes,\n      getRouteInfo: routeId => {\n        var _ssrInfo$routeModules, _ssrInfo$manifest$rou2, _ssrInfo$routeModules2;\n        return {\n          clientLoader: (_ssrInfo$routeModules = ssrInfo.routeModules[routeId]) === null || _ssrInfo$routeModules === void 0 ? void 0 : _ssrInfo$routeModules.clientLoader,\n          hasLoader: ((_ssrInfo$manifest$rou2 = ssrInfo.manifest.routes[routeId]) === null || _ssrInfo$manifest$rou2 === void 0 ? void 0 : _ssrInfo$manifest$rou2.hasLoader) === true,\n          hasHydrateFallback: ((_ssrInfo$routeModules2 = ssrInfo.routeModules[routeId]) === null || _ssrInfo$routeModules2 === void 0 ? void 0 : _ssrInfo$routeModules2.HydrateFallback) != null\n        };\n      },\n      location: window.location,\n      basename: (_window$__reactRouter = window.__reactRouterContext) === null || _window$__reactRouter === void 0 ? void 0 : _window$__reactRouter.basename,\n      isSpaMode: ssrInfo.context.isSpaMode\n    });\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    unstable_instrumentations,\n    mapRouteProperties,\n    future: {\n      middleware: ssrInfo.context.future.v8_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(() => router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n  });\n  ssrInfo.router = router2;\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\nfunction HydratedRouter(props) {\n  var _ssrInfo;\n  if (!router) {\n    router = createHydratedRouter({\n      getContext: props.getContext,\n      unstable_instrumentations: props.unstable_instrumentations\n    });\n  }\n  let [criticalCss, setCriticalCss] = React2.useState(process.env.NODE_ENV === \"development\" ? (_ssrInfo = ssrInfo) === null || _ssrInfo === void 0 ? void 0 : _ssrInfo.context.criticalCss : void 0);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(\"[\".concat(CRITICAL_CSS_DATA_ATTRIBUTE, \"]\")).forEach(element => element.remove());\n    }\n  }, [criticalCss]);\n  let [location2, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe(newState => {\n        if (newState.location !== location2) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location2]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */\n    React2.createElement(React2.Fragment, null, /* @__PURE__ */React2.createElement(FrameworkContext.Provider, {\n      value: {\n        manifest: ssrInfo.manifest,\n        routeModules: ssrInfo.routeModules,\n        future: ssrInfo.context.future,\n        criticalCss,\n        ssr: ssrInfo.context.ssr,\n        isSpaMode: ssrInfo.context.isSpaMode,\n        routeDiscovery: ssrInfo.context.routeDiscovery\n      }\n    }, /* @__PURE__ */React2.createElement(RemixErrorBoundary, {\n      location: location2\n    }, /* @__PURE__ */React2.createElement(RouterProvider2, {\n      router,\n      unstable_onError: props.unstable_onError\n    }))), /* @__PURE__ */React2.createElement(React2.Fragment, null))\n  );\n}\n\n// lib/rsc/browser.tsx\nimport * as React3 from \"react\";\nimport * as ReactDOM2 from \"react-dom\";\nfunction createCallServer(_ref2) {\n  let {\n    createFromReadableStream,\n    createTemporaryReferenceSet,\n    encodeReply,\n    fetch: fetchImplementation = fetch\n  } = _ref2;\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    var _globalVar$__routerAc;\n    let actionId = globalVar.__routerActionID = ((_globalVar$__routerAc = globalVar.__routerActionID) !== null && _globalVar$__routerAc !== void 0 ? _globalVar$__routerAc : globalVar.__routerActionID = 0) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(new Request(location.href, {\n      body: await encodeReply(args, {\n        temporaryReferences\n      }),\n      method: \"POST\",\n      headers: {\n        Accept: \"text/x-component\",\n        \"rsc-action-id\": id\n      }\n    })).then(response => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    globalVar.__reactRouterDataRouter.__setPendingRerender(Promise.resolve(payloadPromise).then(async payload => {\n      if (payload.type === \"redirect\") {\n        if (payload.reload || isExternalLocation(payload.location)) {\n          window.location.href = payload.location;\n          return () => {};\n        }\n        return () => {\n          globalVar.__reactRouterDataRouter.navigate(payload.location, {\n            replace: payload.replace\n          });\n        };\n      }\n      if (payload.type !== \"action\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      const rerender = await payload.rerender;\n      if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n        if (rerender.type === \"redirect\") {\n          if (rerender.reload || isExternalLocation(rerender.location)) {\n            window.location.href = rerender.location;\n            return;\n          }\n          return () => {\n            globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n              replace: rerender.replace\n            });\n          };\n        }\n        return () => {\n          let lastMatch;\n          for (const match of rerender.matches) {\n            var _lastMatch$id, _lastMatch;\n            globalVar.__reactRouterDataRouter.patchRoutes((_lastMatch$id = (_lastMatch = lastMatch) === null || _lastMatch === void 0 ? void 0 : _lastMatch.id) !== null && _lastMatch$id !== void 0 ? _lastMatch$id : null, [createRouteFromServerManifest(match)], true);\n            lastMatch = match;\n          }\n          window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp({\n            loaderData: Object.assign({}, globalVar.__reactRouterDataRouter.state.loaderData, rerender.loaderData),\n            errors: rerender.errors ? Object.assign({}, globalVar.__reactRouterDataRouter.state.errors, rerender.errors) : null\n          });\n        };\n      }\n      return () => {};\n    }).catch(() => {}));\n    return payloadPromise.then(payload => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      return payload.actionResult;\n    });\n  };\n}\nfunction createRouterFromPayload(_ref3) {\n  var _globalVar$__reactRou, _payload$patches;\n  let {\n    fetchImplementation,\n    createFromReadableStream,\n    getContext,\n    payload\n  } = _ref3;\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules) return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = (_globalVar$__reactRou = globalVar.__reactRouterRouteModules) !== null && _globalVar$__reactRou !== void 0 ? _globalVar$__reactRou : {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */new Map();\n  (_payload$patches = payload.patches) === null || _payload$patches === void 0 || _payload$patches.forEach(patch => {\n    var _patches$get;\n    invariant(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    (_patches$get = patches.get(patch.parentId)) === null || _patches$get === void 0 || _patches$get.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(match, payload);\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(...childrenToPatch.map(r => createRouteFromServerManifest(r)));\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = createRouter({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: routeId => {\n        let match = payload.matches.find(m => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n    async patchRoutesOnNavigation(_ref4) {\n      let {\n        path,\n        signal\n      } = _ref4;\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches([path], createFromReadableStream, fetchImplementation, signal);\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(() => globalVar.__reactRouterDataRouter, true, payload.basename, createFromReadableStream, fetchImplementation)\n  });\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__reactRouterDataRouter.subscribe(_ref5 => {\n    let {\n      loaderData,\n      actionData\n    } = _ref5;\n    if (lastLoaderData !== loaderData) {\n      var _globalVar$__routerAc2;\n      globalVar.__routerActionID = ((_globalVar$__routerAc2 = globalVar.__routerActionID) !== null && _globalVar$__routerAc2 !== void 0 ? _globalVar$__routerAc2 : globalVar.__routerActionID = 0) + 1;\n    }\n  });\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = routeUpdateByRouteId => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n    function walkRoutes(routes2, parentId) {\n      return routes2.map(route => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n          return newRoute;\n        }\n        const updatedRoute = _objectSpread({}, route);\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n        return updatedRoute;\n      });\n    }\n    newRoutes.push(...walkRoutes(oldRoutes, void 0));\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\nvar renderedRoutesContext = createContext();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, match => {\n    let M = match;\n    return {\n      hasLoader: M.route.hasLoader,\n      hasClientLoader: M.route.hasClientLoader,\n      hasComponent: M.route.hasComponent,\n      hasAction: M.route.hasAction,\n      hasClientAction: M.route.hasClientAction,\n      hasShouldRevalidate: M.route.hasShouldRevalidate\n    };\n  },\n  // pass map into fetchAndDecode so it can add payloads\n  getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation), ssr, basename,\n  // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match => {\n    let M = match;\n    return M.route.hasComponent && !M.route.element;\n  });\n  return async args => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    for (const match of args.matches) {\n      const renderedRoutes = renderedRoutesById.get(match.route.id);\n      if (renderedRoutes) {\n        for (const rendered of renderedRoutes) {\n          var _rendered$parentId;\n          window.__reactRouterDataRouter.patchRoutes((_rendered$parentId = rendered.parentId) !== null && _rendered$parentId !== void 0 ? _rendered$parentId : null, [createRouteFromServerManifest(rendered)], true);\n        }\n      }\n    }\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, targetRoutes) => {\n    let {\n      request,\n      context\n    } = args;\n    let url = singleFetchUrl(request.url, basename, \"rsc\");\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(new Request(url, await createRequestInit(request)));\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n    invariant(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = {\n        routes: {}\n      };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = {\n          data\n        };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = {\n            error\n          };\n        }\n      }\n      return {\n        status: res.status,\n        data: results\n      };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter(_ref6) {\n  let {\n    createFromReadableStream,\n    fetch: fetchImplementation = fetch,\n    payload,\n    routeDiscovery = \"eager\",\n    getContext\n  } = _ref6;\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let {\n    router: router2,\n    routeModules\n  } = React3.useMemo(() => createRouterFromPayload({\n    payload,\n    fetchImplementation,\n    getContext,\n    createFromReadableStream\n  }), [createFromReadableStream, payload, fetchImplementation, getContext]);\n  React3.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  React3.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [location2, setLocation] = React3.useState(router2.state.location);\n  React3.useLayoutEffect(() => router2.subscribe(newState => {\n    if (newState.location !== location2) {\n      setLocation(newState.location);\n    }\n  }), [router2, location2]);\n  React3.useEffect(() => {\n    var _window$navigator;\n    if (routeDiscovery === \"lazy\" ||\n    // @ts-expect-error - TS doesn't know about this yet\n    ((_window$navigator = window.navigator) === null || _window$navigator === void 0 || (_window$navigator = _window$navigator.connection) === null || _window$navigator === void 0 ? void 0 : _window$navigator.saveData) === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter(path => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation);\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: {\n      mode: \"lazy\",\n      manifestPath: \"/__manifest\"\n    },\n    routeModules\n  };\n  return /* @__PURE__ */React3.createElement(RSCRouterContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React3.createElement(RSCRouterGlobalErrorBoundary, {\n    location: location2\n  }, /* @__PURE__ */React3.createElement(FrameworkContext.Provider, {\n    value: frameworkContext\n  }, /* @__PURE__ */React3.createElement(UNSTABLE_TransitionEnabledRouterProvider, {\n    router: router2,\n    flushSync: ReactDOM2.flushSync\n  }))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  var _payload$errors, _match$clientLoader;\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload === null || payload === void 0 ? void 0 : payload.loaderData[match.id];\n  let hasInitialError = (payload === null || payload === void 0 ? void 0 : payload.errors) && match.id in payload.errors;\n  let initialError = payload === null || payload === void 0 || (_payload$errors = payload.errors) === null || _payload$errors === void 0 ? void 0 : _payload$errors[match.id];\n  let isHydrationRequest = ((_match$clientLoader = match.clientLoader) === null || _match$clientLoader === void 0 ? void 0 : _match$clientLoader.hydrate) === true || !match.hasLoader ||\n  // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  invariant(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader(_objectSpread(_objectSpread({}, args), {}, {\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\"loader\", match.id, match.hasLoader);\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        }));\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } :\n    // We always make the call in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    (_, singleFetch) => callSingleFetch(singleFetch),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction(_objectSpread(_objectSpread({}, args), {}, {\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\"action\", match.id, match.hasLoader);\n        return await callSingleFetch(singleFetch);\n      }\n    })) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(match.id, match.clientLoader, match.hasLoader, false);\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = \"You are trying to call \".concat(fn, \" on a route that does not have a server \").concat(type, \" (routeId: \\\"\").concat(routeId, \"\\\")\");\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  var _globalVar$__reactRou2;\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(\"\".concat(paths[0], \".manifest\"), window.location.origin);\n  }\n  const globalVar = window;\n  let basename = ((_globalVar$__reactRou2 = globalVar.__reactRouterDataRouter.basename) !== null && _globalVar$__reactRou2 !== void 0 ? _globalVar$__reactRou2 : \"\").replace(/^\\/|\\/$/g, \"\");\n  let url = new URL(\"\".concat(basename, \"/.manifest\"), window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, {\n    signal\n  }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach(p => addToFifoQueue(p, discoveredPaths));\n  payload.patches.forEach(p => {\n    var _p$parentId;\n    window.__reactRouterDataRouter.patchRoutes((_p$parentId = p.parentId) !== null && _p$parentId !== void 0 ? _p$parentId : null, [createRouteFromServerManifest(p)]);\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\nfunction isExternalLocation(location2) {\n  const newLocation = new URL(location2, window.location.href);\n  return newLocation.origin !== window.location.origin;\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = chunk => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = chunk => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      var _streamController;\n      (_streamController = streamController) === null || _streamController === void 0 || _streamController.close();\n    });\n  } else {\n    var _streamController2;\n    (_streamController2 = streamController) === null || _streamController2 === void 0 || _streamController2.close();\n  }\n  return rscStream;\n}\nexport { HydratedRouter, RouterProvider2 as RouterProvider, RSCHydratedRouter as unstable_RSCHydratedRouter, createCallServer as unstable_createCallServer, getRSCStream as unstable_getRSCStream };","map":{"version":3,"names":["_objectSpread","RSCRouterGlobalErrorBoundary","deserializeErrors","getHydrationData","populateRSCRouteModules","CRITICAL_CSS_DATA_ATTRIBUTE","ErrorResponseImpl","FrameworkContext","RSCRouterContext","RemixErrorBoundary","RouterProvider","UNSTABLE_TransitionEnabledRouterProvider","createBrowserHistory","createClientRoutes","createClientRoutesWithHMRRevalidationOptOut","createContext","createRequestInit","createRouter","decodeViaTurboStream","getPatchRoutesOnNavigationFunction","getSingleFetchDataStrategyImpl","getTurboStreamSingleFetchDataStrategy","hydrationRouteProperties","invariant","isMutationMethod","mapRouteProperties","noActionDefinedError","setIsHydrated","shouldHydrateRouteLoader","singleFetchUrl","stripIndexParam","useFogOFWarDiscovery","React","ReactDOM","RouterProvider2","props","createElement","flushSync","React2","ssrInfo","router","initSsrInfo","window","__reactRouterContext","__reactRouterManifest","__reactRouterRouteModules","sri","importMap","document","querySelector","textContent","JSON","parse","integrity","err","console","error","context","manifest","routeModules","stateDecodingPromise","routerInitialized","createHydratedRouter","_ref","getContext","unstable_instrumentations","Error","localSsrInfo","stream","then","value","state","catch","e","routes","ssr","isSpaMode","hydrationData","_ssrInfo$manifest$rou","loaderData","root","hasLoader","_window$__reactRouter","getRouteInfo","routeId","_ssrInfo$routeModules","_ssrInfo$manifest$rou2","_ssrInfo$routeModules2","clientLoader","hasHydrateFallback","HydrateFallback","location","basename","errors","router2","history","future","middleware","v8_middleware","dataStrategy","patchRoutesOnNavigation","routeDiscovery","initialized","initialize","createRoutesForHMR","__reactRouterDataRouter","HydratedRouter","_ssrInfo","criticalCss","setCriticalCss","useState","process","env","NODE_ENV","useEffect","querySelectorAll","concat","forEach","element","remove","location2","setLocation","useLayoutEffect","subscribe","newState","Fragment","Provider","unstable_onError","React3","ReactDOM2","createCallServer","_ref2","createFromReadableStream","createTemporaryReferenceSet","encodeReply","fetch","fetchImplementation","globalVar","landedActionId","id","args","_globalVar$__routerAc","actionId","__routerActionID","temporaryReferences","payloadPromise","Request","href","body","method","headers","Accept","response","__setPendingRerender","Promise","resolve","payload","type","reload","isExternalLocation","navigate","replace","rerender","lastMatch","match","matches","_lastMatch$id","_lastMatch","patchRoutes","createRouteFromServerManifest","_internalSetStateDoNotUseOrYouWillBreakYourApp","Object","assign","actionResult","createRouterFromPayload","_ref3","_globalVar$__reactRou","_payload$patches","patches","Map","patch","_patches$get","parentId","has","set","get","push","reduceRight","previous","route","length","children","childrenToPatch","map","r","actionData","find","m","hydrateFallbackElement","_ref4","path","signal","discoveredPaths","fetchAndApplyManifestPatches","getRSCSingleFetchDataStrategy","__routerInitialized","lastLoaderData","_ref5","_globalVar$__routerAc2","_updateRoutesForHMR","routeUpdateByRouteId","oldRoutes","newRoutes","walkRoutes","routes2","routeUpdate","routeModule","hasAction","hasComponent","hasErrorBoundary","newRoute","clientAction","errorElement","handle","index","links","meta","shouldRevalidate","updatedRoute","_internalSetRoutes","renderedRoutesContext","getRouter","M","hasClientLoader","hasClientAction","hasShouldRevalidate","getFetchAndDecodeViaRSC","runClientMiddleware","results","renderedRoutesById","renderedRoutes","rendered","_rendered$parentId","targetRoutes","request","url","searchParams","join","res","status","statusText","text","data","redirect","revalidate","dataKey","entries","RSCHydratedRouter","_ref6","useMemo","_window$navigator","navigator","connection","saveData","registerElement","el","tagName","getAttribute","pathname","URL","origin","nextPaths","add","fetchPatches","paths","Array","from","keys","filter","delete","debouncedFetchPatches","debounce","observer","MutationObserver","observe","documentElement","subtree","childList","attributes","attributeFilter","frameworkContext","unstable_subResourceIntegrity","version","entry","module","imports","mode","manifestPath","_payload$errors","_match$clientLoader","hasInitialData","initialData","hasInitialError","initialError","isHydrationRequest","hydrate","dataRoute","loader","singleFetch","result","serverLoader","preventInvalidServerHandlerCall","callSingleFetch","_","action","serverAction","hasHandler","fn","msg","Set","discoveredPathsMaxSize","URL_LIMIT","getManifestUrl","_globalVar$__reactRou2","sort","toString","clear","p","addToFifoQueue","_p$parentId","queue","size","first","values","next","callback","wait","timeoutId","_len","arguments","_key","clearTimeout","setTimeout","newLocation","getRSCStream","encoder","TextEncoder","streamController","rscStream","ReadableStream","start","controller","handleChunk","chunk","enqueue","encode","__FLIGHT_DATA","readyState","addEventListener","_streamController","close","_streamController2","unstable_RSCHydratedRouter","unstable_createCallServer","unstable_getRSCStream"],"sources":["C:/Users/milen/Desktop/PROGRAMMING/QuizMoodle/frontend/node_modules/react-router/dist/development/dom-export.mjs"],"sourcesContent":["/**\n * react-router v7.9.5\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n\"use client\";\nimport {\n  RSCRouterGlobalErrorBoundary,\n  deserializeErrors,\n  getHydrationData,\n  populateRSCRouteModules\n} from \"./chunk-JG3XND5A.mjs\";\nimport {\n  CRITICAL_CSS_DATA_ATTRIBUTE,\n  ErrorResponseImpl,\n  FrameworkContext,\n  RSCRouterContext,\n  RemixErrorBoundary,\n  RouterProvider,\n  UNSTABLE_TransitionEnabledRouterProvider,\n  createBrowserHistory,\n  createClientRoutes,\n  createClientRoutesWithHMRRevalidationOptOut,\n  createContext,\n  createRequestInit,\n  createRouter,\n  decodeViaTurboStream,\n  getPatchRoutesOnNavigationFunction,\n  getSingleFetchDataStrategyImpl,\n  getTurboStreamSingleFetchDataStrategy,\n  hydrationRouteProperties,\n  invariant,\n  isMutationMethod,\n  mapRouteProperties,\n  noActionDefinedError,\n  setIsHydrated,\n  shouldHydrateRouteLoader,\n  singleFetchUrl,\n  stripIndexParam,\n  useFogOFWarDiscovery\n} from \"./chunk-UIGDSWPH.mjs\";\n\n// lib/dom-export/dom-router-provider.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */ React.createElement(RouterProvider, { flushSync: ReactDOM.flushSync, ...props });\n}\n\n// lib/dom-export/hydrated-router.tsx\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n      if (importMap?.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(\n            importMap.textContent\n          ).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\nfunction createHydratedRouter({\n  getContext,\n  unstable_instrumentations\n}) {\n  initSsrInfo();\n  if (!ssrInfo) {\n    throw new Error(\n      \"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\"\n    );\n  }\n  let localSsrInfo = ssrInfo;\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch((e) => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n  let routes = createClientRoutes(\n    ssrInfo.manifest.routes,\n    ssrInfo.routeModules,\n    ssrInfo.context.state,\n    ssrInfo.context.ssr,\n    ssrInfo.context.isSpaMode\n  );\n  let hydrationData = void 0;\n  if (ssrInfo.context.isSpaMode) {\n    let { loaderData } = ssrInfo.context.state;\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    hydrationData = getHydrationData({\n      state: ssrInfo.context.state,\n      routes,\n      getRouteInfo: (routeId) => ({\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n      }),\n      location: window.location,\n      basename: window.__reactRouterContext?.basename,\n      isSpaMode: ssrInfo.context.isSpaMode\n    });\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    unstable_instrumentations,\n    mapRouteProperties,\n    future: {\n      middleware: ssrInfo.context.future.v8_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(\n      () => router2,\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.basename\n    ),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.ssr,\n      ssrInfo.context.routeDiscovery,\n      ssrInfo.context.isSpaMode,\n      ssrInfo.context.basename\n    )\n  });\n  ssrInfo.router = router2;\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\nfunction HydratedRouter(props) {\n  if (!router) {\n    router = createHydratedRouter({\n      getContext: props.getContext,\n      unstable_instrumentations: props.unstable_instrumentations\n    });\n  }\n  let [criticalCss, setCriticalCss] = React2.useState(\n    process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0\n  );\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());\n    }\n  }, [criticalCss]);\n  let [location2, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe((newState) => {\n        if (newState.location !== location2) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location2]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(\n    router,\n    ssrInfo.manifest,\n    ssrInfo.routeModules,\n    ssrInfo.context.ssr,\n    ssrInfo.context.routeDiscovery,\n    ssrInfo.context.isSpaMode\n  );\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\n      FrameworkContext.Provider,\n      {\n        value: {\n          manifest: ssrInfo.manifest,\n          routeModules: ssrInfo.routeModules,\n          future: ssrInfo.context.future,\n          criticalCss,\n          ssr: ssrInfo.context.ssr,\n          isSpaMode: ssrInfo.context.isSpaMode,\n          routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n      },\n      /* @__PURE__ */ React2.createElement(RemixErrorBoundary, { location: location2 }, /* @__PURE__ */ React2.createElement(\n        RouterProvider2,\n        {\n          router,\n          unstable_onError: props.unstable_onError\n        }\n      ))\n    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))\n  );\n}\n\n// lib/rsc/browser.tsx\nimport * as React3 from \"react\";\nimport * as ReactDOM2 from \"react-dom\";\nfunction createCallServer({\n  createFromReadableStream,\n  createTemporaryReferenceSet,\n  encodeReply,\n  fetch: fetchImplementation = fetch\n}) {\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(\n      new Request(location.href, {\n        body: await encodeReply(args, { temporaryReferences }),\n        method: \"POST\",\n        headers: {\n          Accept: \"text/x-component\",\n          \"rsc-action-id\": id\n        }\n      })\n    ).then((response) => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    globalVar.__reactRouterDataRouter.__setPendingRerender(\n      Promise.resolve(payloadPromise).then(async (payload) => {\n        if (payload.type === \"redirect\") {\n          if (payload.reload || isExternalLocation(payload.location)) {\n            window.location.href = payload.location;\n            return () => {\n            };\n          }\n          return () => {\n            globalVar.__reactRouterDataRouter.navigate(payload.location, {\n              replace: payload.replace\n            });\n          };\n        }\n        if (payload.type !== \"action\") {\n          throw new Error(\"Unexpected payload type\");\n        }\n        const rerender = await payload.rerender;\n        if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n          if (rerender.type === \"redirect\") {\n            if (rerender.reload || isExternalLocation(rerender.location)) {\n              window.location.href = rerender.location;\n              return;\n            }\n            return () => {\n              globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n                replace: rerender.replace\n              });\n            };\n          }\n          return () => {\n            let lastMatch;\n            for (const match of rerender.matches) {\n              globalVar.__reactRouterDataRouter.patchRoutes(\n                lastMatch?.id ?? null,\n                [createRouteFromServerManifest(match)],\n                true\n              );\n              lastMatch = match;\n            }\n            window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(\n              {\n                loaderData: Object.assign(\n                  {},\n                  globalVar.__reactRouterDataRouter.state.loaderData,\n                  rerender.loaderData\n                ),\n                errors: rerender.errors ? Object.assign(\n                  {},\n                  globalVar.__reactRouterDataRouter.state.errors,\n                  rerender.errors\n                ) : null\n              }\n            );\n          };\n        }\n        return () => {\n        };\n      }).catch(() => {\n      })\n    );\n    return payloadPromise.then((payload) => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      return payload.actionResult;\n    });\n  };\n}\nfunction createRouterFromPayload({\n  fetchImplementation,\n  createFromReadableStream,\n  getContext,\n  payload\n}) {\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules)\n    return {\n      router: globalVar.__reactRouterDataRouter,\n      routeModules: globalVar.__reactRouterRouteModules\n    };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */ new Map();\n  payload.patches?.forEach((patch) => {\n    invariant(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(\n      match,\n      payload\n    );\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\n        );\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = createRouter({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: (routeId) => {\n        let match = payload.matches.find((m) => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n    async patchRoutesOnNavigation({ path, signal }) {\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches(\n        [path],\n        createFromReadableStream,\n        fetchImplementation,\n        signal\n      );\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(\n      () => globalVar.__reactRouterDataRouter,\n      true,\n      payload.basename,\n      createFromReadableStream,\n      fetchImplementation\n    )\n  });\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__reactRouterDataRouter.subscribe(({ loaderData, actionData }) => {\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = (routeUpdateByRouteId) => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n    function walkRoutes(routes2, parentId) {\n      return routes2.map((route) => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n          return newRoute;\n        }\n        const updatedRoute = { ...route };\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n        return updatedRoute;\n      });\n    }\n    newRoutes.push(\n      ...walkRoutes(oldRoutes, void 0)\n    );\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\nvar renderedRoutesContext = createContext();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(\n    getRouter,\n    (match) => {\n      let M = match;\n      return {\n        hasLoader: M.route.hasLoader,\n        hasClientLoader: M.route.hasClientLoader,\n        hasComponent: M.route.hasComponent,\n        hasAction: M.route.hasAction,\n        hasClientAction: M.route.hasClientAction,\n        hasShouldRevalidate: M.route.hasShouldRevalidate\n      };\n    },\n    // pass map into fetchAndDecode so it can add payloads\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\n    ssr,\n    basename,\n    // If the route has a component but we don't have an element, we need to hit\n    // the server loader flow regardless of whether the client loader calls\n    // `serverLoader` or not, otherwise we'll have nothing to render.\n    (match) => {\n      let M = match;\n      return M.route.hasComponent && !M.route.element;\n    }\n  );\n  return async (args) => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */ new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    for (const match of args.matches) {\n      const renderedRoutes = renderedRoutesById.get(match.route.id);\n      if (renderedRoutes) {\n        for (const rendered of renderedRoutes) {\n          window.__reactRouterDataRouter.patchRoutes(\n            rendered.parentId ?? null,\n            [createRouteFromServerManifest(rendered)],\n            true\n          );\n        }\n      }\n    }\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, targetRoutes) => {\n    let { request, context } = args;\n    let url = singleFetchUrl(request.url, basename, \"rsc\");\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(\n      new Request(url, await createRequestInit(request))\n    );\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n    invariant(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = { routes: {} };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = { data };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = { error };\n        }\n      }\n      return { status: res.status, data: results };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter({\n  createFromReadableStream,\n  fetch: fetchImplementation = fetch,\n  payload,\n  routeDiscovery = \"eager\",\n  getContext\n}) {\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let { router: router2, routeModules } = React3.useMemo(\n    () => createRouterFromPayload({\n      payload,\n      fetchImplementation,\n      getContext,\n      createFromReadableStream\n    }),\n    [createFromReadableStream, payload, fetchImplementation, getContext]\n  );\n  React3.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  React3.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [location2, setLocation] = React3.useState(router2.state.location);\n  React3.useLayoutEffect(\n    () => router2.subscribe((newState) => {\n      if (newState.location !== location2) {\n        setLocation(newState.location);\n      }\n    }),\n    [router2, location2]\n  );\n  React3.useEffect(() => {\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(\n          paths,\n          createFromReadableStream,\n          fetchImplementation\n        );\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\n    routeModules\n  };\n  return /* @__PURE__ */ React3.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React3.createElement(RSCRouterGlobalErrorBoundary, { location: location2 }, /* @__PURE__ */ React3.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React3.createElement(UNSTABLE_TransitionEnabledRouterProvider, { router: router2, flushSync: ReactDOM2.flushSync }))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  invariant(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({\n          ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\n              \"loader\",\n              match.id,\n              match.hasLoader\n            );\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } : (\n      // We always make the call in this RSC world since even if we don't\n      // have a `loader` we may need to get the `element` implementation\n      (_, singleFetch) => callSingleFetch(singleFetch)\n    ),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\n      ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\n          \"action\",\n          match.id,\n          match.hasLoader\n        );\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(\n      match.id,\n      match.clientLoader,\n      match.hasLoader,\n      false\n    );\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n  const globalVar = window;\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(\n    /^\\/|\\/$/g,\n    \"\"\n  );\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, { signal }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\n  payload.patches.forEach((p) => {\n    window.__reactRouterDataRouter.patchRoutes(\n      p.parentId ?? null,\n      [createRouteFromServerManifest(p)]\n    );\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\nfunction isExternalLocation(location2) {\n  const newLocation = new URL(location2, window.location.href);\n  return newLocation.origin !== window.location.origin;\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = (chunk) => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = (chunk) => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n  return rscStream;\n}\nexport {\n  HydratedRouter,\n  RouterProvider2 as RouterProvider,\n  RSCHydratedRouter as unstable_RSCHydratedRouter,\n  createCallServer as unstable_createCallServer,\n  getRSCStream as unstable_getRSCStream\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAAC,OAAAA,aAAA;AACb,SACEC,4BAA4B,EAC5BC,iBAAiB,EACjBC,gBAAgB,EAChBC,uBAAuB,QAClB,sBAAsB;AAC7B,SACEC,2BAA2B,EAC3BC,iBAAiB,EACjBC,gBAAgB,EAChBC,gBAAgB,EAChBC,kBAAkB,EAClBC,cAAc,EACdC,wCAAwC,EACxCC,oBAAoB,EACpBC,kBAAkB,EAClBC,2CAA2C,EAC3CC,aAAa,EACbC,iBAAiB,EACjBC,YAAY,EACZC,oBAAoB,EACpBC,kCAAkC,EAClCC,8BAA8B,EAC9BC,qCAAqC,EACrCC,wBAAwB,EACxBC,SAAS,EACTC,gBAAgB,EAChBC,kBAAkB,EAClBC,oBAAoB,EACpBC,aAAa,EACbC,wBAAwB,EACxBC,cAAc,EACdC,eAAe,EACfC,oBAAoB,QACf,sBAAsB;;AAE7B;AACA,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAO,KAAKC,QAAQ,MAAM,WAAW;AACrC,SAASC,eAAeA,CAACC,KAAK,EAAE;EAC9B,OAAO,eAAgBH,KAAK,CAACI,aAAa,CAAC1B,cAAc,EAAAV,aAAA;IAAIqC,SAAS,EAAEJ,QAAQ,CAACI;EAAS,GAAKF,KAAK,CAAE,CAAC;AACzG;;AAEA;AACA,OAAO,KAAKG,MAAM,MAAM,OAAO;AAC/B,IAAIC,OAAO,GAAG,IAAI;AAClB,IAAIC,MAAM,GAAG,IAAI;AACjB,SAASC,WAAWA,CAAA,EAAG;EACrB,IAAI,CAACF,OAAO,IAAIG,MAAM,CAACC,oBAAoB,IAAID,MAAM,CAACE,qBAAqB,IAAIF,MAAM,CAACG,yBAAyB,EAAE;IAC/G,IAAIH,MAAM,CAACE,qBAAqB,CAACE,GAAG,KAAK,IAAI,EAAE;MAC7C,MAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,sBAAsB,CAAC;MAChE,IAAIF,SAAS,aAATA,SAAS,eAATA,SAAS,CAAEG,WAAW,EAAE;QAC1B,IAAI;UACFR,MAAM,CAACE,qBAAqB,CAACE,GAAG,GAAGK,IAAI,CAACC,KAAK,CAC3CL,SAAS,CAACG,WACZ,CAAC,CAACG,SAAS;QACb,CAAC,CAAC,OAAOC,GAAG,EAAE;UACZC,OAAO,CAACC,KAAK,CAAC,4BAA4B,EAAEF,GAAG,CAAC;QAClD;MACF;IACF;IACAf,OAAO,GAAG;MACRkB,OAAO,EAAEf,MAAM,CAACC,oBAAoB;MACpCe,QAAQ,EAAEhB,MAAM,CAACE,qBAAqB;MACtCe,YAAY,EAAEjB,MAAM,CAACG,yBAAyB;MAC9Ce,oBAAoB,EAAE,KAAK,CAAC;MAC5BpB,MAAM,EAAE,KAAK,CAAC;MACdqB,iBAAiB,EAAE;IACrB,CAAC;EACH;AACF;AACA,SAASC,oBAAoBA,CAAAC,IAAA,EAG1B;EAAA,IAH2B;IAC5BC,UAAU;IACVC;EACF,CAAC,GAAAF,IAAA;EACCtB,WAAW,CAAC,CAAC;EACb,IAAI,CAACF,OAAO,EAAE;IACZ,MAAM,IAAI2B,KAAK,CACb,mHACF,CAAC;EACH;EACA,IAAIC,YAAY,GAAG5B,OAAO;EAC1B,IAAI,CAACA,OAAO,CAACqB,oBAAoB,EAAE;IACjC,IAAIQ,MAAM,GAAG7B,OAAO,CAACkB,OAAO,CAACW,MAAM;IACnC7C,SAAS,CAAC6C,MAAM,EAAE,2CAA2C,CAAC;IAC9D7B,OAAO,CAACkB,OAAO,CAACW,MAAM,GAAG,KAAK,CAAC;IAC/B7B,OAAO,CAACqB,oBAAoB,GAAG1C,oBAAoB,CAACkD,MAAM,EAAE1B,MAAM,CAAC,CAAC2B,IAAI,CAAEC,KAAK,IAAK;MAClF/B,OAAO,CAACkB,OAAO,CAACc,KAAK,GAAGD,KAAK,CAACA,KAAK;MACnCH,YAAY,CAACP,oBAAoB,CAACU,KAAK,GAAG,IAAI;IAChD,CAAC,CAAC,CAACE,KAAK,CAAEC,CAAC,IAAK;MACdN,YAAY,CAACP,oBAAoB,CAACJ,KAAK,GAAGiB,CAAC;IAC7C,CAAC,CAAC;EACJ;EACA,IAAIlC,OAAO,CAACqB,oBAAoB,CAACJ,KAAK,EAAE;IACtC,MAAMjB,OAAO,CAACqB,oBAAoB,CAACJ,KAAK;EAC1C;EACA,IAAI,CAACjB,OAAO,CAACqB,oBAAoB,CAACU,KAAK,EAAE;IACvC,MAAM/B,OAAO,CAACqB,oBAAoB;EACpC;EACA,IAAIc,MAAM,GAAG7D,kBAAkB,CAC7B0B,OAAO,CAACmB,QAAQ,CAACgB,MAAM,EACvBnC,OAAO,CAACoB,YAAY,EACpBpB,OAAO,CAACkB,OAAO,CAACc,KAAK,EACrBhC,OAAO,CAACkB,OAAO,CAACkB,GAAG,EACnBpC,OAAO,CAACkB,OAAO,CAACmB,SAClB,CAAC;EACD,IAAIC,aAAa,GAAG,KAAK,CAAC;EAC1B,IAAItC,OAAO,CAACkB,OAAO,CAACmB,SAAS,EAAE;IAAA,IAAAE,qBAAA;IAC7B,IAAI;MAAEC;IAAW,CAAC,GAAGxC,OAAO,CAACkB,OAAO,CAACc,KAAK;IAC1C,IAAI,CAAAO,qBAAA,GAAAvC,OAAO,CAACmB,QAAQ,CAACgB,MAAM,CAACM,IAAI,cAAAF,qBAAA,eAA5BA,qBAAA,CAA8BG,SAAS,IAAIF,UAAU,IAAI,MAAM,IAAIA,UAAU,EAAE;MACjFF,aAAa,GAAG;QACdE,UAAU,EAAE;UACVC,IAAI,EAAED,UAAU,CAACC;QACnB;MACF,CAAC;IACH;EACF,CAAC,MAAM;IAAA,IAAAE,qBAAA;IACLL,aAAa,GAAG1E,gBAAgB,CAAC;MAC/BoE,KAAK,EAAEhC,OAAO,CAACkB,OAAO,CAACc,KAAK;MAC5BG,MAAM;MACNS,YAAY,EAAGC,OAAO;QAAA,IAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA;QAAA,OAAM;UAC1BC,YAAY,GAAAH,qBAAA,GAAE9C,OAAO,CAACoB,YAAY,CAACyB,OAAO,CAAC,cAAAC,qBAAA,uBAA7BA,qBAAA,CAA+BG,YAAY;UACzDP,SAAS,EAAE,EAAAK,sBAAA,GAAA/C,OAAO,CAACmB,QAAQ,CAACgB,MAAM,CAACU,OAAO,CAAC,cAAAE,sBAAA,uBAAhCA,sBAAA,CAAkCL,SAAS,MAAK,IAAI;UAC/DQ,kBAAkB,EAAE,EAAAF,sBAAA,GAAAhD,OAAO,CAACoB,YAAY,CAACyB,OAAO,CAAC,cAAAG,sBAAA,uBAA7BA,sBAAA,CAA+BG,eAAe,KAAI;QACxE,CAAC;MAAA,CAAC;MACFC,QAAQ,EAAEjD,MAAM,CAACiD,QAAQ;MACzBC,QAAQ,GAAAV,qBAAA,GAAExC,MAAM,CAACC,oBAAoB,cAAAuC,qBAAA,uBAA3BA,qBAAA,CAA6BU,QAAQ;MAC/ChB,SAAS,EAAErC,OAAO,CAACkB,OAAO,CAACmB;IAC7B,CAAC,CAAC;IACF,IAAIC,aAAa,IAAIA,aAAa,CAACgB,MAAM,EAAE;MACzChB,aAAa,CAACgB,MAAM,GAAG3F,iBAAiB,CAAC2E,aAAa,CAACgB,MAAM,CAAC;IAChE;EACF;EACA,IAAIC,OAAO,GAAG7E,YAAY,CAAC;IACzByD,MAAM;IACNqB,OAAO,EAAEnF,oBAAoB,CAAC,CAAC;IAC/BgF,QAAQ,EAAErD,OAAO,CAACkB,OAAO,CAACmC,QAAQ;IAClC5B,UAAU;IACVa,aAAa;IACbvD,wBAAwB;IACxB2C,yBAAyB;IACzBxC,kBAAkB;IAClBuE,MAAM,EAAE;MACNC,UAAU,EAAE1D,OAAO,CAACkB,OAAO,CAACuC,MAAM,CAACE;IACrC,CAAC;IACDC,YAAY,EAAE9E,qCAAqC,CACjD,MAAMyE,OAAO,EACbvD,OAAO,CAACmB,QAAQ,EAChBnB,OAAO,CAACoB,YAAY,EACpBpB,OAAO,CAACkB,OAAO,CAACkB,GAAG,EACnBpC,OAAO,CAACkB,OAAO,CAACmC,QAClB,CAAC;IACDQ,uBAAuB,EAAEjF,kCAAkC,CACzDoB,OAAO,CAACmB,QAAQ,EAChBnB,OAAO,CAACoB,YAAY,EACpBpB,OAAO,CAACkB,OAAO,CAACkB,GAAG,EACnBpC,OAAO,CAACkB,OAAO,CAAC4C,cAAc,EAC9B9D,OAAO,CAACkB,OAAO,CAACmB,SAAS,EACzBrC,OAAO,CAACkB,OAAO,CAACmC,QAClB;EACF,CAAC,CAAC;EACFrD,OAAO,CAACC,MAAM,GAAGsD,OAAO;EACxB,IAAIA,OAAO,CAACvB,KAAK,CAAC+B,WAAW,EAAE;IAC7B/D,OAAO,CAACsB,iBAAiB,GAAG,IAAI;IAChCiC,OAAO,CAACS,UAAU,CAAC,CAAC;EACtB;EACAT,OAAO,CAACU,kBAAkB,GAAG;EAC7B1F,2CAA2C;EAC3C4B,MAAM,CAAC+D,uBAAuB,GAAGX,OAAO;EACxC,OAAOA,OAAO;AAChB;AACA,SAASY,cAAcA,CAACvE,KAAK,EAAE;EAAA,IAAAwE,QAAA;EAC7B,IAAI,CAACnE,MAAM,EAAE;IACXA,MAAM,GAAGsB,oBAAoB,CAAC;MAC5BE,UAAU,EAAE7B,KAAK,CAAC6B,UAAU;MAC5BC,yBAAyB,EAAE9B,KAAK,CAAC8B;IACnC,CAAC,CAAC;EACJ;EACA,IAAI,CAAC2C,WAAW,EAAEC,cAAc,CAAC,GAAGvE,MAAM,CAACwE,QAAQ,CACjDC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,IAAAN,QAAA,GAAGpE,OAAO,cAAAoE,QAAA,uBAAPA,QAAA,CAASlD,OAAO,CAACmD,WAAW,GAAG,KAAK,CAC/E,CAAC;EACDtE,MAAM,CAAC4E,SAAS,CAAC,MAAM;IACrB,IAAIH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;MAC1CJ,cAAc,CAAC,KAAK,CAAC,CAAC;IACxB;EACF,CAAC,EAAE,EAAE,CAAC;EACNvE,MAAM,CAAC4E,SAAS,CAAC,MAAM;IACrB,IAAIH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,IAAIL,WAAW,KAAK,KAAK,CAAC,EAAE;MACpE5D,QAAQ,CAACmE,gBAAgB,KAAAC,MAAA,CAAK/G,2BAA2B,MAAG,CAAC,CAACgH,OAAO,CAAEC,OAAO,IAAKA,OAAO,CAACC,MAAM,CAAC,CAAC,CAAC;IACtG;EACF,CAAC,EAAE,CAACX,WAAW,CAAC,CAAC;EACjB,IAAI,CAACY,SAAS,EAAEC,WAAW,CAAC,GAAGnF,MAAM,CAACwE,QAAQ,CAACtE,MAAM,CAAC+B,KAAK,CAACoB,QAAQ,CAAC;EACrErD,MAAM,CAACoF,eAAe,CAAC,MAAM;IAC3B,IAAInF,OAAO,IAAIA,OAAO,CAACC,MAAM,IAAI,CAACD,OAAO,CAACsB,iBAAiB,EAAE;MAC3DtB,OAAO,CAACsB,iBAAiB,GAAG,IAAI;MAChCtB,OAAO,CAACC,MAAM,CAAC+D,UAAU,CAAC,CAAC;IAC7B;EACF,CAAC,EAAE,EAAE,CAAC;EACNjE,MAAM,CAACoF,eAAe,CAAC,MAAM;IAC3B,IAAInF,OAAO,IAAIA,OAAO,CAACC,MAAM,EAAE;MAC7B,OAAOD,OAAO,CAACC,MAAM,CAACmF,SAAS,CAAEC,QAAQ,IAAK;QAC5C,IAAIA,QAAQ,CAACjC,QAAQ,KAAK6B,SAAS,EAAE;UACnCC,WAAW,CAACG,QAAQ,CAACjC,QAAQ,CAAC;QAChC;MACF,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAAC6B,SAAS,CAAC,CAAC;EACfjG,SAAS,CAACgB,OAAO,EAAE,wCAAwC,CAAC;EAC5DR,oBAAoB,CAClBS,MAAM,EACND,OAAO,CAACmB,QAAQ,EAChBnB,OAAO,CAACoB,YAAY,EACpBpB,OAAO,CAACkB,OAAO,CAACkB,GAAG,EACnBpC,OAAO,CAACkB,OAAO,CAAC4C,cAAc,EAC9B9D,OAAO,CAACkB,OAAO,CAACmB,SAClB,CAAC;EACD;IACE;IACA;IACA;IAAgBtC,MAAM,CAACF,aAAa,CAACE,MAAM,CAACuF,QAAQ,EAAE,IAAI,EAAE,eAAgBvF,MAAM,CAACF,aAAa,CAC9F7B,gBAAgB,CAACuH,QAAQ,EACzB;MACExD,KAAK,EAAE;QACLZ,QAAQ,EAAEnB,OAAO,CAACmB,QAAQ;QAC1BC,YAAY,EAAEpB,OAAO,CAACoB,YAAY;QAClCqC,MAAM,EAAEzD,OAAO,CAACkB,OAAO,CAACuC,MAAM;QAC9BY,WAAW;QACXjC,GAAG,EAAEpC,OAAO,CAACkB,OAAO,CAACkB,GAAG;QACxBC,SAAS,EAAErC,OAAO,CAACkB,OAAO,CAACmB,SAAS;QACpCyB,cAAc,EAAE9D,OAAO,CAACkB,OAAO,CAAC4C;MAClC;IACF,CAAC,EACD,eAAgB/D,MAAM,CAACF,aAAa,CAAC3B,kBAAkB,EAAE;MAAEkF,QAAQ,EAAE6B;IAAU,CAAC,EAAE,eAAgBlF,MAAM,CAACF,aAAa,CACpHF,eAAe,EACf;MACEM,MAAM;MACNuF,gBAAgB,EAAE5F,KAAK,CAAC4F;IAC1B,CACF,CAAC,CACH,CAAC,EAAE,eAAgBzF,MAAM,CAACF,aAAa,CAACE,MAAM,CAACuF,QAAQ,EAAE,IAAI,CAAC;EAAC;AAEnE;;AAEA;AACA,OAAO,KAAKG,MAAM,MAAM,OAAO;AAC/B,OAAO,KAAKC,SAAS,MAAM,WAAW;AACtC,SAASC,gBAAgBA,CAAAC,KAAA,EAKtB;EAAA,IALuB;IACxBC,wBAAwB;IACxBC,2BAA2B;IAC3BC,WAAW;IACXC,KAAK,EAAEC,mBAAmB,GAAGD;EAC/B,CAAC,GAAAJ,KAAA;EACC,MAAMM,SAAS,GAAG/F,MAAM;EACxB,IAAIgG,cAAc,GAAG,CAAC;EACtB,OAAO,OAAOC,EAAE,EAAEC,IAAI,KAAK;IAAA,IAAAC,qBAAA;IACzB,IAAIC,QAAQ,GAAGL,SAAS,CAACM,gBAAgB,GAAG,EAAAF,qBAAA,GAACJ,SAAS,CAACM,gBAAgB,cAAAF,qBAAA,cAAAA,qBAAA,GAAKJ,SAAS,CAACM,gBAAgB,GAAG,CAAC,IAAK,CAAC;IAChH,MAAMC,mBAAmB,GAAGX,2BAA2B,CAAC,CAAC;IACzD,MAAMY,cAAc,GAAGT,mBAAmB,CACxC,IAAIU,OAAO,CAACvD,QAAQ,CAACwD,IAAI,EAAE;MACzBC,IAAI,EAAE,MAAMd,WAAW,CAACM,IAAI,EAAE;QAAEI;MAAoB,CAAC,CAAC;MACtDK,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACPC,MAAM,EAAE,kBAAkB;QAC1B,eAAe,EAAEZ;MACnB;IACF,CAAC,CACH,CAAC,CAACtE,IAAI,CAAEmF,QAAQ,IAAK;MACnB,IAAI,CAACA,QAAQ,CAACJ,IAAI,EAAE;QAClB,MAAM,IAAIlF,KAAK,CAAC,kBAAkB,CAAC;MACrC;MACA,OAAOkE,wBAAwB,CAACoB,QAAQ,CAACJ,IAAI,EAAE;QAC7CJ;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACFP,SAAS,CAAChC,uBAAuB,CAACgD,oBAAoB,CACpDC,OAAO,CAACC,OAAO,CAACV,cAAc,CAAC,CAAC5E,IAAI,CAAC,MAAOuF,OAAO,IAAK;MACtD,IAAIA,OAAO,CAACC,IAAI,KAAK,UAAU,EAAE;QAC/B,IAAID,OAAO,CAACE,MAAM,IAAIC,kBAAkB,CAACH,OAAO,CAACjE,QAAQ,CAAC,EAAE;UAC1DjD,MAAM,CAACiD,QAAQ,CAACwD,IAAI,GAAGS,OAAO,CAACjE,QAAQ;UACvC,OAAO,MAAM,CACb,CAAC;QACH;QACA,OAAO,MAAM;UACX8C,SAAS,CAAChC,uBAAuB,CAACuD,QAAQ,CAACJ,OAAO,CAACjE,QAAQ,EAAE;YAC3DsE,OAAO,EAAEL,OAAO,CAACK;UACnB,CAAC,CAAC;QACJ,CAAC;MACH;MACA,IAAIL,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI3F,KAAK,CAAC,yBAAyB,CAAC;MAC5C;MACA,MAAMgG,QAAQ,GAAG,MAAMN,OAAO,CAACM,QAAQ;MACvC,IAAIA,QAAQ,IAAIxB,cAAc,GAAGI,QAAQ,IAAIL,SAAS,CAACM,gBAAgB,IAAID,QAAQ,EAAE;QACnF,IAAIoB,QAAQ,CAACL,IAAI,KAAK,UAAU,EAAE;UAChC,IAAIK,QAAQ,CAACJ,MAAM,IAAIC,kBAAkB,CAACG,QAAQ,CAACvE,QAAQ,CAAC,EAAE;YAC5DjD,MAAM,CAACiD,QAAQ,CAACwD,IAAI,GAAGe,QAAQ,CAACvE,QAAQ;YACxC;UACF;UACA,OAAO,MAAM;YACX8C,SAAS,CAAChC,uBAAuB,CAACuD,QAAQ,CAACE,QAAQ,CAACvE,QAAQ,EAAE;cAC5DsE,OAAO,EAAEC,QAAQ,CAACD;YACpB,CAAC,CAAC;UACJ,CAAC;QACH;QACA,OAAO,MAAM;UACX,IAAIE,SAAS;UACb,KAAK,MAAMC,KAAK,IAAIF,QAAQ,CAACG,OAAO,EAAE;YAAA,IAAAC,aAAA,EAAAC,UAAA;YACpC9B,SAAS,CAAChC,uBAAuB,CAAC+D,WAAW,EAAAF,aAAA,IAAAC,UAAA,GAC3CJ,SAAS,cAAAI,UAAA,uBAATA,UAAA,CAAW5B,EAAE,cAAA2B,aAAA,cAAAA,aAAA,GAAI,IAAI,EACrB,CAACG,6BAA6B,CAACL,KAAK,CAAC,CAAC,EACtC,IACF,CAAC;YACDD,SAAS,GAAGC,KAAK;UACnB;UACA1H,MAAM,CAAC+D,uBAAuB,CAACiE,8CAA8C,CAC3E;YACE3F,UAAU,EAAE4F,MAAM,CAACC,MAAM,CACvB,CAAC,CAAC,EACFnC,SAAS,CAAChC,uBAAuB,CAAClC,KAAK,CAACQ,UAAU,EAClDmF,QAAQ,CAACnF,UACX,CAAC;YACDc,MAAM,EAAEqE,QAAQ,CAACrE,MAAM,GAAG8E,MAAM,CAACC,MAAM,CACrC,CAAC,CAAC,EACFnC,SAAS,CAAChC,uBAAuB,CAAClC,KAAK,CAACsB,MAAM,EAC9CqE,QAAQ,CAACrE,MACX,CAAC,GAAG;UACN,CACF,CAAC;QACH,CAAC;MACH;MACA,OAAO,MAAM,CACb,CAAC;IACH,CAAC,CAAC,CAACrB,KAAK,CAAC,MAAM,CACf,CAAC,CACH,CAAC;IACD,OAAOyE,cAAc,CAAC5E,IAAI,CAAEuF,OAAO,IAAK;MACtC,IAAIA,OAAO,CAACC,IAAI,KAAK,QAAQ,IAAID,OAAO,CAACC,IAAI,KAAK,UAAU,EAAE;QAC5D,MAAM,IAAI3F,KAAK,CAAC,yBAAyB,CAAC;MAC5C;MACA,OAAO0F,OAAO,CAACiB,YAAY;IAC7B,CAAC,CAAC;EACJ,CAAC;AACH;AACA,SAASC,uBAAuBA,CAAAC,KAAA,EAK7B;EAAA,IAAAC,qBAAA,EAAAC,gBAAA;EAAA,IAL8B;IAC/BzC,mBAAmB;IACnBJ,wBAAwB;IACxBpE,UAAU;IACV4F;EACF,CAAC,GAAAmB,KAAA;EACC,MAAMtC,SAAS,GAAG/F,MAAM;EACxB,IAAI+F,SAAS,CAAChC,uBAAuB,IAAIgC,SAAS,CAAC5F,yBAAyB,EAC1E,OAAO;IACLL,MAAM,EAAEiG,SAAS,CAAChC,uBAAuB;IACzC9C,YAAY,EAAE8E,SAAS,CAAC5F;EAC1B,CAAC;EACH,IAAI+G,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE,MAAM,IAAI3F,KAAK,CAAC,sBAAsB,CAAC;EACtEuE,SAAS,CAAC5F,yBAAyB,IAAAmI,qBAAA,GAAGvC,SAAS,CAAC5F,yBAAyB,cAAAmI,qBAAA,cAAAA,qBAAA,GAAI,CAAC,CAAC;EAC/E5K,uBAAuB,CAACqI,SAAS,CAAC5F,yBAAyB,EAAE+G,OAAO,CAACS,OAAO,CAAC;EAC7E,IAAIa,OAAO,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC;EACvC,CAAAF,gBAAA,GAAArB,OAAO,CAACsB,OAAO,cAAAD,gBAAA,eAAfA,gBAAA,CAAiB5D,OAAO,CAAE+D,KAAK,IAAK;IAAA,IAAAC,YAAA;IAClC9J,SAAS,CAAC6J,KAAK,CAACE,QAAQ,EAAE,wBAAwB,CAAC;IACnD,IAAI,CAACJ,OAAO,CAACK,GAAG,CAACH,KAAK,CAACE,QAAQ,CAAC,EAAE;MAChCJ,OAAO,CAACM,GAAG,CAACJ,KAAK,CAACE,QAAQ,EAAE,EAAE,CAAC;IACjC;IACA,CAAAD,YAAA,GAAAH,OAAO,CAACO,GAAG,CAACL,KAAK,CAACE,QAAQ,CAAC,cAAAD,YAAA,eAA3BA,YAAA,CAA6BK,IAAI,CAACN,KAAK,CAAC;EAC1C,CAAC,CAAC;EACF,IAAI1G,MAAM,GAAGkF,OAAO,CAACS,OAAO,CAACsB,WAAW,CAAC,CAACC,QAAQ,EAAExB,KAAK,KAAK;IAC5D,MAAMyB,KAAK,GAAGpB,6BAA6B,CACzCL,KAAK,EACLR,OACF,CAAC;IACD,IAAIgC,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACvBD,KAAK,CAACE,QAAQ,GAAGH,QAAQ;MACzB,IAAII,eAAe,GAAGd,OAAO,CAACO,GAAG,CAACrB,KAAK,CAACzB,EAAE,CAAC;MAC3C,IAAIqD,eAAe,EAAE;QACnBH,KAAK,CAACE,QAAQ,CAACL,IAAI,CACjB,GAAGM,eAAe,CAACC,GAAG,CAAEC,CAAC,IAAKzB,6BAA6B,CAACyB,CAAC,CAAC,CAChE,CAAC;MACH;IACF;IACA,OAAO,CAACL,KAAK,CAAC;EAChB,CAAC,EAAE,EAAE,CAAC;EACNpD,SAAS,CAAChC,uBAAuB,GAAGxF,YAAY,CAAC;IAC/CyD,MAAM;IACNV,UAAU;IACV4B,QAAQ,EAAEgE,OAAO,CAAChE,QAAQ;IAC1BG,OAAO,EAAEnF,oBAAoB,CAAC,CAAC;IAC/BiE,aAAa,EAAE1E,gBAAgB,CAAC;MAC9BoE,KAAK,EAAE;QACLQ,UAAU,EAAE6E,OAAO,CAAC7E,UAAU;QAC9BoH,UAAU,EAAEvC,OAAO,CAACuC,UAAU;QAC9BtG,MAAM,EAAE+D,OAAO,CAAC/D;MAClB,CAAC;MACDnB,MAAM;MACNS,YAAY,EAAGC,OAAO,IAAK;QACzB,IAAIgF,KAAK,GAAGR,OAAO,CAACS,OAAO,CAAC+B,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAAC1D,EAAE,KAAKvD,OAAO,CAAC;QACzD7D,SAAS,CAAC6I,KAAK,EAAE,4BAA4B,CAAC;QAC9C,OAAO;UACL5E,YAAY,EAAE4E,KAAK,CAAC5E,YAAY;UAChCP,SAAS,EAAEmF,KAAK,CAACnF,SAAS;UAC1BQ,kBAAkB,EAAE2E,KAAK,CAACkC,sBAAsB,IAAI;QACtD,CAAC;MACH,CAAC;MACD3G,QAAQ,EAAEiE,OAAO,CAACjE,QAAQ;MAC1BC,QAAQ,EAAEgE,OAAO,CAAChE,QAAQ;MAC1BhB,SAAS,EAAE;IACb,CAAC,CAAC;IACF,MAAMwB,uBAAuBA,CAAAmG,KAAA,EAAmB;MAAA,IAAlB;QAAEC,IAAI;QAAEC;MAAO,CAAC,GAAAF,KAAA;MAC5C,IAAIG,eAAe,CAACnB,GAAG,CAACiB,IAAI,CAAC,EAAE;QAC7B;MACF;MACA,MAAMG,4BAA4B,CAChC,CAACH,IAAI,CAAC,EACNpE,wBAAwB,EACxBI,mBAAmB,EACnBiE,MACF,CAAC;IACH,CAAC;IACD;IACAtG,YAAY,EAAEyG,6BAA6B,CACzC,MAAMnE,SAAS,CAAChC,uBAAuB,EACvC,IAAI,EACJmD,OAAO,CAAChE,QAAQ,EAChBwC,wBAAwB,EACxBI,mBACF;EACF,CAAC,CAAC;EACF,IAAIC,SAAS,CAAChC,uBAAuB,CAAClC,KAAK,CAAC+B,WAAW,EAAE;IACvDmC,SAAS,CAACoE,mBAAmB,GAAG,IAAI;IACpCpE,SAAS,CAAChC,uBAAuB,CAACF,UAAU,CAAC,CAAC;EAChD,CAAC,MAAM;IACLkC,SAAS,CAACoE,mBAAmB,GAAG,KAAK;EACvC;EACA,IAAIC,cAAc,GAAG,KAAK,CAAC;EAC3BrE,SAAS,CAAChC,uBAAuB,CAACkB,SAAS,CAACoF,KAAA,IAAgC;IAAA,IAA/B;MAAEhI,UAAU;MAAEoH;IAAW,CAAC,GAAAY,KAAA;IACrE,IAAID,cAAc,KAAK/H,UAAU,EAAE;MAAA,IAAAiI,sBAAA;MACjCvE,SAAS,CAACM,gBAAgB,GAAG,EAAAiE,sBAAA,GAACvE,SAAS,CAACM,gBAAgB,cAAAiE,sBAAA,cAAAA,sBAAA,GAAKvE,SAAS,CAACM,gBAAgB,GAAG,CAAC,IAAK,CAAC;IACnG;EACF,CAAC,CAAC;EACFN,SAAS,CAAChC,uBAAuB,CAACwG,mBAAmB,GAAIC,oBAAoB,IAAK;IAChF,MAAMC,SAAS,GAAGzK,MAAM,CAAC+D,uBAAuB,CAAC/B,MAAM;IACvD,MAAM0I,SAAS,GAAG,EAAE;IACpB,SAASC,UAAUA,CAACC,OAAO,EAAEhC,QAAQ,EAAE;MACrC,OAAOgC,OAAO,CAACrB,GAAG,CAAEJ,KAAK,IAAK;QAC5B,MAAM0B,WAAW,GAAGL,oBAAoB,CAACzB,GAAG,CAACI,KAAK,CAAClD,EAAE,CAAC;QACtD,IAAI4E,WAAW,EAAE;UACf,MAAM;YACJC,WAAW;YACXC,SAAS;YACTC,YAAY;YACZC,gBAAgB;YAChB1I;UACF,CAAC,GAAGsI,WAAW;UACf,MAAMK,QAAQ,GAAGnD,6BAA6B,CAAC;YAC7CoD,YAAY,EAAEL,WAAW,CAACK,YAAY;YACtCrI,YAAY,EAAEgI,WAAW,CAAChI,YAAY;YACtC8B,OAAO,EAAEuE,KAAK,CAACvE,OAAO;YACtBwG,YAAY,EAAEjC,KAAK,CAACiC,YAAY;YAChCC,MAAM,EAAElC,KAAK,CAACkC,MAAM;YACpBN,SAAS;YACTC,YAAY;YACZC,gBAAgB;YAChB1I,SAAS;YACTqH,sBAAsB,EAAET,KAAK,CAACS,sBAAsB;YACpD3D,EAAE,EAAEkD,KAAK,CAAClD,EAAE;YACZqF,KAAK,EAAEnC,KAAK,CAACmC,KAAK;YAClBC,KAAK,EAAET,WAAW,CAACS,KAAK;YACxBC,IAAI,EAAEV,WAAW,CAACU,IAAI;YACtB5C,QAAQ;YACRkB,IAAI,EAAEX,KAAK,CAACW,IAAI;YAChB2B,gBAAgB,EAAEX,WAAW,CAACW;UAChC,CAAC,CAAC;UACF,IAAItC,KAAK,CAACE,QAAQ,EAAE;YAClB6B,QAAQ,CAAC7B,QAAQ,GAAGsB,UAAU,CAACxB,KAAK,CAACE,QAAQ,EAAEF,KAAK,CAAClD,EAAE,CAAC;UAC1D;UACA,OAAOiF,QAAQ;QACjB;QACA,MAAMQ,YAAY,GAAApO,aAAA,KAAQ6L,KAAK,CAAE;QACjC,IAAIA,KAAK,CAACE,QAAQ,EAAE;UAClBqC,YAAY,CAACrC,QAAQ,GAAGsB,UAAU,CAACxB,KAAK,CAACE,QAAQ,EAAEF,KAAK,CAAClD,EAAE,CAAC;QAC9D;QACA,OAAOyF,YAAY;MACrB,CAAC,CAAC;IACJ;IACAhB,SAAS,CAAC1B,IAAI,CACZ,GAAG2B,UAAU,CAACF,SAAS,EAAE,KAAK,CAAC,CACjC,CAAC;IACDzK,MAAM,CAAC+D,uBAAuB,CAAC4H,kBAAkB,CAACjB,SAAS,CAAC;EAC9D,CAAC;EACD,OAAO;IACL5K,MAAM,EAAEiG,SAAS,CAAChC,uBAAuB;IACzC9C,YAAY,EAAE8E,SAAS,CAAC5F;EAC1B,CAAC;AACH;AACA,IAAIyL,qBAAqB,GAAGvN,aAAa,CAAC,CAAC;AAC3C,SAAS6L,6BAA6BA,CAAC2B,SAAS,EAAE5J,GAAG,EAAEiB,QAAQ,EAAEwC,wBAAwB,EAAEI,mBAAmB,EAAE;EAC9G,IAAIrC,YAAY,GAAG/E,8BAA8B,CAC/CmN,SAAS,EACRnE,KAAK,IAAK;IACT,IAAIoE,CAAC,GAAGpE,KAAK;IACb,OAAO;MACLnF,SAAS,EAAEuJ,CAAC,CAAC3C,KAAK,CAAC5G,SAAS;MAC5BwJ,eAAe,EAAED,CAAC,CAAC3C,KAAK,CAAC4C,eAAe;MACxCf,YAAY,EAAEc,CAAC,CAAC3C,KAAK,CAAC6B,YAAY;MAClCD,SAAS,EAAEe,CAAC,CAAC3C,KAAK,CAAC4B,SAAS;MAC5BiB,eAAe,EAAEF,CAAC,CAAC3C,KAAK,CAAC6C,eAAe;MACxCC,mBAAmB,EAAEH,CAAC,CAAC3C,KAAK,CAAC8C;IAC/B,CAAC;EACH,CAAC;EACD;EACAC,uBAAuB,CAACxG,wBAAwB,EAAEI,mBAAmB,CAAC,EACtE7D,GAAG,EACHiB,QAAQ;EACR;EACA;EACA;EACCwE,KAAK,IAAK;IACT,IAAIoE,CAAC,GAAGpE,KAAK;IACb,OAAOoE,CAAC,CAAC3C,KAAK,CAAC6B,YAAY,IAAI,CAACc,CAAC,CAAC3C,KAAK,CAACvE,OAAO;EACjD,CACF,CAAC;EACD,OAAO,MAAOsB,IAAI,IAAKA,IAAI,CAACiG,mBAAmB,CAAC,YAAY;IAC1D,IAAIpL,OAAO,GAAGmF,IAAI,CAACnF,OAAO;IAC1BA,OAAO,CAAC+H,GAAG,CAAC8C,qBAAqB,EAAE,EAAE,CAAC;IACtC,IAAIQ,OAAO,GAAG,MAAM3I,YAAY,CAACyC,IAAI,CAAC;IACtC,MAAMmG,kBAAkB,GAAG,eAAgB,IAAI5D,GAAG,CAAC,CAAC;IACpD,KAAK,MAAMU,KAAK,IAAIpI,OAAO,CAACgI,GAAG,CAAC6C,qBAAqB,CAAC,EAAE;MACtD,IAAI,CAACS,kBAAkB,CAACxD,GAAG,CAACM,KAAK,CAAClD,EAAE,CAAC,EAAE;QACrCoG,kBAAkB,CAACvD,GAAG,CAACK,KAAK,CAAClD,EAAE,EAAE,EAAE,CAAC;MACtC;MACAoG,kBAAkB,CAACtD,GAAG,CAACI,KAAK,CAAClD,EAAE,CAAC,CAAC+C,IAAI,CAACG,KAAK,CAAC;IAC9C;IACA,KAAK,MAAMzB,KAAK,IAAIxB,IAAI,CAACyB,OAAO,EAAE;MAChC,MAAM2E,cAAc,GAAGD,kBAAkB,CAACtD,GAAG,CAACrB,KAAK,CAACyB,KAAK,CAAClD,EAAE,CAAC;MAC7D,IAAIqG,cAAc,EAAE;QAClB,KAAK,MAAMC,QAAQ,IAAID,cAAc,EAAE;UAAA,IAAAE,kBAAA;UACrCxM,MAAM,CAAC+D,uBAAuB,CAAC+D,WAAW,EAAA0E,kBAAA,GACxCD,QAAQ,CAAC3D,QAAQ,cAAA4D,kBAAA,cAAAA,kBAAA,GAAI,IAAI,EACzB,CAACzE,6BAA6B,CAACwE,QAAQ,CAAC,CAAC,EACzC,IACF,CAAC;QACH;MACF;IACF;IACA,OAAOH,OAAO;EAChB,CAAC,CAAC;AACJ;AACA,SAASF,uBAAuBA,CAACxG,wBAAwB,EAAEI,mBAAmB,EAAE;EAC9E,OAAO,OAAOI,IAAI,EAAEhD,QAAQ,EAAEuJ,YAAY,KAAK;IAC7C,IAAI;MAAEC,OAAO;MAAE3L;IAAQ,CAAC,GAAGmF,IAAI;IAC/B,IAAIyG,GAAG,GAAGxN,cAAc,CAACuN,OAAO,CAACC,GAAG,EAAEzJ,QAAQ,EAAE,KAAK,CAAC;IACtD,IAAIwJ,OAAO,CAAC/F,MAAM,KAAK,KAAK,EAAE;MAC5BgG,GAAG,GAAGvN,eAAe,CAACuN,GAAG,CAAC;MAC1B,IAAIF,YAAY,EAAE;QAChBE,GAAG,CAACC,YAAY,CAAC9D,GAAG,CAAC,SAAS,EAAE2D,YAAY,CAACI,IAAI,CAAC,GAAG,CAAC,CAAC;MACzD;IACF;IACA,IAAIC,GAAG,GAAG,MAAMhH,mBAAmB,CACjC,IAAIU,OAAO,CAACmG,GAAG,EAAE,MAAMrO,iBAAiB,CAACoO,OAAO,CAAC,CACnD,CAAC;IACD,IAAII,GAAG,CAACC,MAAM,IAAI,GAAG,IAAI,CAACD,GAAG,CAAClG,OAAO,CAACiC,GAAG,CAAC,kBAAkB,CAAC,EAAE;MAC7D,MAAM,IAAIjL,iBAAiB,CAACkP,GAAG,CAACC,MAAM,EAAED,GAAG,CAACE,UAAU,EAAE,MAAMF,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC;IAC3E;IACApO,SAAS,CAACiO,GAAG,CAACpG,IAAI,EAAE,4BAA4B,CAAC;IACjD,IAAI;MACF,MAAMQ,OAAO,GAAG,MAAMxB,wBAAwB,CAACoH,GAAG,CAACpG,IAAI,EAAE;QACvDJ,mBAAmB,EAAE,KAAK;MAC5B,CAAC,CAAC;MACF,IAAIY,OAAO,CAACC,IAAI,KAAK,UAAU,EAAE;QAC/B,OAAO;UACL4F,MAAM,EAAED,GAAG,CAACC,MAAM;UAClBG,IAAI,EAAE;YACJC,QAAQ,EAAE;cACRA,QAAQ,EAAEjG,OAAO,CAACjE,QAAQ;cAC1BmE,MAAM,EAAEF,OAAO,CAACE,MAAM;cACtBG,OAAO,EAAEL,OAAO,CAACK,OAAO;cACxB6F,UAAU,EAAE,KAAK;cACjBL,MAAM,EAAE7F,OAAO,CAAC6F;YAClB;UACF;QACF,CAAC;MACH;MACA,IAAI7F,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI3F,KAAK,CAAC,yBAAyB,CAAC;MAC5C;MACAT,OAAO,CAACgI,GAAG,CAAC6C,qBAAqB,CAAC,CAAC5C,IAAI,CAAC,GAAG9B,OAAO,CAACS,OAAO,CAAC;MAC3D,IAAIyE,OAAO,GAAG;QAAEpK,MAAM,EAAE,CAAC;MAAE,CAAC;MAC5B,MAAMqL,OAAO,GAAGvO,gBAAgB,CAAC4N,OAAO,CAAC/F,MAAM,CAAC,GAAG,YAAY,GAAG,YAAY;MAC9E,KAAK,IAAI,CAACjE,OAAO,EAAEwK,IAAI,CAAC,IAAIjF,MAAM,CAACqF,OAAO,CAACpG,OAAO,CAACmG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;QAClEjB,OAAO,CAACpK,MAAM,CAACU,OAAO,CAAC,GAAG;UAAEwK;QAAK,CAAC;MACpC;MACA,IAAIhG,OAAO,CAAC/D,MAAM,EAAE;QAClB,KAAK,IAAI,CAACT,OAAO,EAAE5B,KAAK,CAAC,IAAImH,MAAM,CAACqF,OAAO,CAACpG,OAAO,CAAC/D,MAAM,CAAC,EAAE;UAC3DiJ,OAAO,CAACpK,MAAM,CAACU,OAAO,CAAC,GAAG;YAAE5B;UAAM,CAAC;QACrC;MACF;MACA,OAAO;QAAEiM,MAAM,EAAED,GAAG,CAACC,MAAM;QAAEG,IAAI,EAAEd;MAAQ,CAAC;IAC9C,CAAC,CAAC,OAAOrK,CAAC,EAAE;MACV,MAAM,IAAIP,KAAK,CAAC,+BAA+B,CAAC;IAClD;EACF,CAAC;AACH;AACA,SAAS+L,iBAAiBA,CAAAC,KAAA,EAMvB;EAAA,IANwB;IACzB9H,wBAAwB;IACxBG,KAAK,EAAEC,mBAAmB,GAAGD,KAAK;IAClCqB,OAAO;IACPvD,cAAc,GAAG,OAAO;IACxBrC;EACF,CAAC,GAAAkM,KAAA;EACC,IAAItG,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE,MAAM,IAAI3F,KAAK,CAAC,sBAAsB,CAAC;EACtE,IAAI;IAAE1B,MAAM,EAAEsD,OAAO;IAAEnC;EAAa,CAAC,GAAGqE,MAAM,CAACmI,OAAO,CACpD,MAAMrF,uBAAuB,CAAC;IAC5BlB,OAAO;IACPpB,mBAAmB;IACnBxE,UAAU;IACVoE;EACF,CAAC,CAAC,EACF,CAACA,wBAAwB,EAAEwB,OAAO,EAAEpB,mBAAmB,EAAExE,UAAU,CACrE,CAAC;EACDgE,MAAM,CAACd,SAAS,CAAC,MAAM;IACrBvF,aAAa,CAAC,CAAC;EACjB,CAAC,EAAE,EAAE,CAAC;EACNqG,MAAM,CAACN,eAAe,CAAC,MAAM;IAC3B,MAAMe,SAAS,GAAG/F,MAAM;IACxB,IAAI,CAAC+F,SAAS,CAACoE,mBAAmB,EAAE;MAClCpE,SAAS,CAACoE,mBAAmB,GAAG,IAAI;MACpCpE,SAAS,CAAChC,uBAAuB,CAACF,UAAU,CAAC,CAAC;IAChD;EACF,CAAC,EAAE,EAAE,CAAC;EACN,IAAI,CAACiB,SAAS,EAAEC,WAAW,CAAC,GAAGO,MAAM,CAAClB,QAAQ,CAAChB,OAAO,CAACvB,KAAK,CAACoB,QAAQ,CAAC;EACtEqC,MAAM,CAACN,eAAe,CACpB,MAAM5B,OAAO,CAAC6B,SAAS,CAAEC,QAAQ,IAAK;IACpC,IAAIA,QAAQ,CAACjC,QAAQ,KAAK6B,SAAS,EAAE;MACnCC,WAAW,CAACG,QAAQ,CAACjC,QAAQ,CAAC;IAChC;EACF,CAAC,CAAC,EACF,CAACG,OAAO,EAAE0B,SAAS,CACrB,CAAC;EACDQ,MAAM,CAACd,SAAS,CAAC,MAAM;IAAA,IAAAkJ,iBAAA;IACrB,IAAI/J,cAAc,KAAK,MAAM;IAAI;IACjC,EAAA+J,iBAAA,GAAA1N,MAAM,CAAC2N,SAAS,cAAAD,iBAAA,gBAAAA,iBAAA,GAAhBA,iBAAA,CAAkBE,UAAU,cAAAF,iBAAA,uBAA5BA,iBAAA,CAA8BG,QAAQ,MAAK,IAAI,EAAE;MAC/C;IACF;IACA,SAASC,eAAeA,CAACC,EAAE,EAAE;MAC3B,IAAIjE,IAAI,GAAGiE,EAAE,CAACC,OAAO,KAAK,MAAM,GAAGD,EAAE,CAACE,YAAY,CAAC,QAAQ,CAAC,GAAGF,EAAE,CAACE,YAAY,CAAC,MAAM,CAAC;MACtF,IAAI,CAACnE,IAAI,EAAE;QACT;MACF;MACA,IAAIoE,QAAQ,GAAGH,EAAE,CAACC,OAAO,KAAK,GAAG,GAAGD,EAAE,CAACG,QAAQ,GAAG,IAAIC,GAAG,CAACrE,IAAI,EAAE9J,MAAM,CAACiD,QAAQ,CAACmL,MAAM,CAAC,CAACF,QAAQ;MAChG,IAAI,CAAClE,eAAe,CAACnB,GAAG,CAACqF,QAAQ,CAAC,EAAE;QAClCG,SAAS,CAACC,GAAG,CAACJ,QAAQ,CAAC;MACzB;IACF;IACA,eAAeK,YAAYA,CAAA,EAAG;MAC5BjO,QAAQ,CAACmE,gBAAgB,CAAC,uCAAuC,CAAC,CAACE,OAAO,CAACmJ,eAAe,CAAC;MAC3F,IAAIU,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACL,SAAS,CAACM,IAAI,CAAC,CAAC,CAAC,CAACC,MAAM,CAAE9E,IAAI,IAAK;QACxD,IAAIE,eAAe,CAACnB,GAAG,CAACiB,IAAI,CAAC,EAAE;UAC7BuE,SAAS,CAACQ,MAAM,CAAC/E,IAAI,CAAC;UACtB,OAAO,KAAK;QACd;QACA,OAAO,IAAI;MACb,CAAC,CAAC;MACF,IAAI0E,KAAK,CAACpF,MAAM,KAAK,CAAC,EAAE;QACtB;MACF;MACA,IAAI;QACF,MAAMa,4BAA4B,CAChCuE,KAAK,EACL9I,wBAAwB,EACxBI,mBACF,CAAC;MACH,CAAC,CAAC,OAAO/D,CAAC,EAAE;QACVlB,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAEiB,CAAC,CAAC;MACtD;IACF;IACA,IAAI+M,qBAAqB,GAAGC,QAAQ,CAACR,YAAY,EAAE,GAAG,CAAC;IACvDA,YAAY,CAAC,CAAC;IACd,IAAIS,QAAQ,GAAG,IAAIC,gBAAgB,CAAC,MAAMH,qBAAqB,CAAC,CAAC,CAAC;IAClEE,QAAQ,CAACE,OAAO,CAAC5O,QAAQ,CAAC6O,eAAe,EAAE;MACzCC,OAAO,EAAE,IAAI;MACbC,SAAS,EAAE,IAAI;MACfC,UAAU,EAAE,IAAI;MAChBC,eAAe,EAAE,CAAC,eAAe,EAAE,MAAM,EAAE,QAAQ;IACrD,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC5L,cAAc,EAAE+B,wBAAwB,EAAEI,mBAAmB,CAAC,CAAC;EACnE,MAAM0J,gBAAgB,GAAG;IACvBlM,MAAM,EAAE;MACN;MACA;MACAE,aAAa,EAAE,KAAK;MACpBiM,6BAA6B,EAAE;IACjC,CAAC;IACDvN,SAAS,EAAE,KAAK;IAChBD,GAAG,EAAE,IAAI;IACTiC,WAAW,EAAE,EAAE;IACflD,QAAQ,EAAE;MACRgB,MAAM,EAAE,CAAC,CAAC;MACV0N,OAAO,EAAE,GAAG;MACZ/C,GAAG,EAAE,EAAE;MACPgD,KAAK,EAAE;QACLC,MAAM,EAAE,EAAE;QACVC,OAAO,EAAE;MACX;IACF,CAAC;IACDlM,cAAc,EAAE;MAAEmM,IAAI,EAAE,MAAM;MAAEC,YAAY,EAAE;IAAc,CAAC;IAC7D9O;EACF,CAAC;EACD,OAAO,eAAgBqE,MAAM,CAAC5F,aAAa,CAAC5B,gBAAgB,CAACsH,QAAQ,EAAE;IAAExD,KAAK,EAAE;EAAK,CAAC,EAAE,eAAgB0D,MAAM,CAAC5F,aAAa,CAACnC,4BAA4B,EAAE;IAAE0F,QAAQ,EAAE6B;EAAU,CAAC,EAAE,eAAgBQ,MAAM,CAAC5F,aAAa,CAAC7B,gBAAgB,CAACuH,QAAQ,EAAE;IAAExD,KAAK,EAAE4N;EAAiB,CAAC,EAAE,eAAgBlK,MAAM,CAAC5F,aAAa,CAACzB,wCAAwC,EAAE;IAAE6B,MAAM,EAAEsD,OAAO;IAAEzD,SAAS,EAAE4F,SAAS,CAAC5F;EAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AACzZ;AACA,SAASoI,6BAA6BA,CAACL,KAAK,EAAER,OAAO,EAAE;EAAA,IAAA8I,eAAA,EAAAC,mBAAA;EACrD,IAAIC,cAAc,GAAGhJ,OAAO,IAAIQ,KAAK,CAACzB,EAAE,IAAIiB,OAAO,CAAC7E,UAAU;EAC9D,IAAI8N,WAAW,GAAGjJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE7E,UAAU,CAACqF,KAAK,CAACzB,EAAE,CAAC;EAC/C,IAAImK,eAAe,GAAG,CAAAlJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE/D,MAAM,KAAIuE,KAAK,CAACzB,EAAE,IAAIiB,OAAO,CAAC/D,MAAM;EACnE,IAAIkN,YAAY,GAAGnJ,OAAO,aAAPA,OAAO,gBAAA8I,eAAA,GAAP9I,OAAO,CAAE/D,MAAM,cAAA6M,eAAA,uBAAfA,eAAA,CAAkBtI,KAAK,CAACzB,EAAE,CAAC;EAC9C,IAAIqK,kBAAkB,GAAG,EAAAL,mBAAA,GAAAvI,KAAK,CAAC5E,YAAY,cAAAmN,mBAAA,uBAAlBA,mBAAA,CAAoBM,OAAO,MAAK,IAAI,IAAI,CAAC7I,KAAK,CAACnF,SAAS;EAAI;EACrF;EACA;EACAmF,KAAK,CAACsD,YAAY,IAAI,CAACtD,KAAK,CAAC9C,OAAO;EACpC/F,SAAS,CAACmB,MAAM,CAACG,yBAAyB,CAAC;EAC3CzC,uBAAuB,CAACsC,MAAM,CAACG,yBAAyB,EAAEuH,KAAK,CAAC;EAChE,IAAI8I,SAAS,GAAG;IACdvK,EAAE,EAAEyB,KAAK,CAACzB,EAAE;IACZrB,OAAO,EAAE8C,KAAK,CAAC9C,OAAO;IACtBwG,YAAY,EAAE1D,KAAK,CAAC0D,YAAY;IAChCC,MAAM,EAAE3D,KAAK,CAAC2D,MAAM;IACpBJ,gBAAgB,EAAEvD,KAAK,CAACuD,gBAAgB;IACxCrB,sBAAsB,EAAElC,KAAK,CAACkC,sBAAsB;IACpD0B,KAAK,EAAE5D,KAAK,CAAC4D,KAAK;IAClBmF,MAAM,EAAE/I,KAAK,CAAC5E,YAAY,GAAG,OAAOoD,IAAI,EAAEwK,WAAW,KAAK;MACxD,IAAI;QACF,IAAIC,MAAM,GAAG,MAAMjJ,KAAK,CAAC5E,YAAY,CAAAxF,aAAA,CAAAA,aAAA,KAChC4I,IAAI;UACP0K,YAAY,EAAEA,CAAA,KAAM;YAClBC,+BAA+B,CAC7B,QAAQ,EACRnJ,KAAK,CAACzB,EAAE,EACRyB,KAAK,CAACnF,SACR,CAAC;YACD,IAAI+N,kBAAkB,EAAE;cACtB,IAAIJ,cAAc,EAAE;gBAClB,OAAOC,WAAW;cACpB;cACA,IAAIC,eAAe,EAAE;gBACnB,MAAMC,YAAY;cACpB;YACF;YACA,OAAOS,eAAe,CAACJ,WAAW,CAAC;UACrC;QAAC,EACF,CAAC;QACF,OAAOC,MAAM;MACf,CAAC,SAAS;QACRL,kBAAkB,GAAG,KAAK;MAC5B;IACF,CAAC;IACC;IACA;IACA,CAACS,CAAC,EAAEL,WAAW,KAAKI,eAAe,CAACJ,WAAW,CAChD;IACDM,MAAM,EAAEtJ,KAAK,CAACyD,YAAY,GAAG,CAACjF,IAAI,EAAEwK,WAAW,KAAKhJ,KAAK,CAACyD,YAAY,CAAA7N,aAAA,CAAAA,aAAA,KACjE4I,IAAI;MACP+K,YAAY,EAAE,MAAAA,CAAA,KAAY;QACxBJ,+BAA+B,CAC7B,QAAQ,EACRnJ,KAAK,CAACzB,EAAE,EACRyB,KAAK,CAACnF,SACR,CAAC;QACD,OAAO,MAAMuO,eAAe,CAACJ,WAAW,CAAC;MAC3C;IAAC,EACF,CAAC,GAAGhJ,KAAK,CAACqD,SAAS,GAAG,CAACgG,CAAC,EAAEL,WAAW,KAAKI,eAAe,CAACJ,WAAW,CAAC,GAAG,MAAM;MAC9E,MAAM1R,oBAAoB,CAAC,QAAQ,EAAE0I,KAAK,CAACzB,EAAE,CAAC;IAChD,CAAC;IACD6D,IAAI,EAAEpC,KAAK,CAACoC,IAAI;IAChB2B,gBAAgB,EAAE/D,KAAK,CAAC+D,gBAAgB;IACxC;IACA;IACAlJ,SAAS,EAAE,IAAI;IACfwJ,eAAe,EAAErE,KAAK,CAAC5E,YAAY,IAAI,IAAI;IAC3CiI,SAAS,EAAErD,KAAK,CAACqD,SAAS;IAC1BiB,eAAe,EAAEtE,KAAK,CAACyD,YAAY,IAAI,IAAI;IAC3Cc,mBAAmB,EAAEvE,KAAK,CAAC+D,gBAAgB,IAAI;EACjD,CAAC;EACD,IAAI,OAAO+E,SAAS,CAACC,MAAM,KAAK,UAAU,EAAE;IAC1CD,SAAS,CAACC,MAAM,CAACF,OAAO,GAAGrR,wBAAwB,CACjDwI,KAAK,CAACzB,EAAE,EACRyB,KAAK,CAAC5E,YAAY,EAClB4E,KAAK,CAACnF,SAAS,EACf,KACF,CAAC;EACH;EACA,OAAOiO,SAAS;AAClB;AACA,SAASM,eAAeA,CAACJ,WAAW,EAAE;EACpC7R,SAAS,CAAC,OAAO6R,WAAW,KAAK,UAAU,EAAE,+BAA+B,CAAC;EAC7E,OAAOA,WAAW,CAAC,CAAC;AACtB;AACA,SAASG,+BAA+BA,CAAC1J,IAAI,EAAEzE,OAAO,EAAEwO,UAAU,EAAE;EAClE,IAAI,CAACA,UAAU,EAAE;IACf,IAAIC,EAAE,GAAGhK,IAAI,KAAK,QAAQ,GAAG,gBAAgB,GAAG,gBAAgB;IAChE,IAAIiK,GAAG,6BAAA1M,MAAA,CAA6ByM,EAAE,8CAAAzM,MAAA,CAA2CyC,IAAI,mBAAAzC,MAAA,CAAehC,OAAO,QAAI;IAC/G7B,OAAO,CAACC,KAAK,CAACsQ,GAAG,CAAC;IAClB,MAAM,IAAIxT,iBAAiB,CAAC,GAAG,EAAE,aAAa,EAAE,IAAI4D,KAAK,CAAC4P,GAAG,CAAC,EAAE,IAAI,CAAC;EACvE;AACF;AACA,IAAI/C,SAAS,GAAG,eAAgB,IAAIgD,GAAG,CAAC,CAAC;AACzC,IAAIC,sBAAsB,GAAG,GAAG;AAChC,IAAItH,eAAe,GAAG,eAAgB,IAAIqH,GAAG,CAAC,CAAC;AAC/C,IAAIE,SAAS,GAAG,IAAI;AACpB,SAASC,cAAcA,CAAChD,KAAK,EAAE;EAAA,IAAAiD,sBAAA;EAC7B,IAAIjD,KAAK,CAACpF,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,IAAI;EACb;EACA,IAAIoF,KAAK,CAACpF,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,IAAI+E,GAAG,IAAAzJ,MAAA,CAAI8J,KAAK,CAAC,CAAC,CAAC,gBAAaxO,MAAM,CAACiD,QAAQ,CAACmL,MAAM,CAAC;EAChE;EACA,MAAMrI,SAAS,GAAG/F,MAAM;EACxB,IAAIkD,QAAQ,GAAG,EAAAuO,sBAAA,GAAC1L,SAAS,CAAChC,uBAAuB,CAACb,QAAQ,cAAAuO,sBAAA,cAAAA,sBAAA,GAAI,EAAE,EAAElK,OAAO,CACvE,UAAU,EACV,EACF,CAAC;EACD,IAAIoF,GAAG,GAAG,IAAIwB,GAAG,IAAAzJ,MAAA,CAAIxB,QAAQ,iBAAclD,MAAM,CAACiD,QAAQ,CAACmL,MAAM,CAAC;EAClEzB,GAAG,CAACC,YAAY,CAAC9D,GAAG,CAAC,OAAO,EAAE0F,KAAK,CAACkD,IAAI,CAAC,CAAC,CAAC7E,IAAI,CAAC,GAAG,CAAC,CAAC;EACrD,OAAOF,GAAG;AACZ;AACA,eAAe1C,4BAA4BA,CAACuE,KAAK,EAAE9I,wBAAwB,EAAEI,mBAAmB,EAAEiE,MAAM,EAAE;EACxG,IAAI4C,GAAG,GAAG6E,cAAc,CAAChD,KAAK,CAAC;EAC/B,IAAI7B,GAAG,IAAI,IAAI,EAAE;IACf;EACF;EACA,IAAIA,GAAG,CAACgF,QAAQ,CAAC,CAAC,CAACvI,MAAM,GAAGmI,SAAS,EAAE;IACrClD,SAAS,CAACuD,KAAK,CAAC,CAAC;IACjB;EACF;EACA,IAAI9K,QAAQ,GAAG,MAAMhB,mBAAmB,CAAC,IAAIU,OAAO,CAACmG,GAAG,EAAE;IAAE5C;EAAO,CAAC,CAAC,CAAC;EACtE,IAAI,CAACjD,QAAQ,CAACJ,IAAI,IAAII,QAAQ,CAACiG,MAAM,GAAG,GAAG,IAAIjG,QAAQ,CAACiG,MAAM,IAAI,GAAG,EAAE;IACrE,MAAM,IAAIvL,KAAK,CAAC,mDAAmD,CAAC;EACtE;EACA,IAAI0F,OAAO,GAAG,MAAMxB,wBAAwB,CAACoB,QAAQ,CAACJ,IAAI,EAAE;IAC1DJ,mBAAmB,EAAE,KAAK;EAC5B,CAAC,CAAC;EACF,IAAIY,OAAO,CAACC,IAAI,KAAK,UAAU,EAAE;IAC/B,MAAM,IAAI3F,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EACAgN,KAAK,CAAC7J,OAAO,CAAEkN,CAAC,IAAKC,cAAc,CAACD,CAAC,EAAE7H,eAAe,CAAC,CAAC;EACxD9C,OAAO,CAACsB,OAAO,CAAC7D,OAAO,CAAEkN,CAAC,IAAK;IAAA,IAAAE,WAAA;IAC7B/R,MAAM,CAAC+D,uBAAuB,CAAC+D,WAAW,EAAAiK,WAAA,GACxCF,CAAC,CAACjJ,QAAQ,cAAAmJ,WAAA,cAAAA,WAAA,GAAI,IAAI,EAClB,CAAChK,6BAA6B,CAAC8J,CAAC,CAAC,CACnC,CAAC;EACH,CAAC,CAAC;AACJ;AACA,SAASC,cAAcA,CAAChI,IAAI,EAAEkI,KAAK,EAAE;EACnC,IAAIA,KAAK,CAACC,IAAI,IAAIX,sBAAsB,EAAE;IACxC,IAAIY,KAAK,GAAGF,KAAK,CAACG,MAAM,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACxQ,KAAK;IACvCoQ,KAAK,CAACnD,MAAM,CAACqD,KAAK,CAAC;EACrB;EACAF,KAAK,CAAC1D,GAAG,CAACxE,IAAI,CAAC;AACjB;AACA,SAASiF,QAAQA,CAACsD,QAAQ,EAAEC,IAAI,EAAE;EAChC,IAAIC,SAAS;EACb,OAAO,YAAa;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAArJ,MAAA,EAATlD,IAAI,OAAAuI,KAAA,CAAA+D,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;MAAJxM,IAAI,CAAAwM,IAAA,IAAAD,SAAA,CAAAC,IAAA;IAAA;IACb1S,MAAM,CAAC2S,YAAY,CAACJ,SAAS,CAAC;IAC9BA,SAAS,GAAGvS,MAAM,CAAC4S,UAAU,CAAC,MAAMP,QAAQ,CAAC,GAAGnM,IAAI,CAAC,EAAEoM,IAAI,CAAC;EAC9D,CAAC;AACH;AACA,SAASjL,kBAAkBA,CAACvC,SAAS,EAAE;EACrC,MAAM+N,WAAW,GAAG,IAAI1E,GAAG,CAACrJ,SAAS,EAAE9E,MAAM,CAACiD,QAAQ,CAACwD,IAAI,CAAC;EAC5D,OAAOoM,WAAW,CAACzE,MAAM,KAAKpO,MAAM,CAACiD,QAAQ,CAACmL,MAAM;AACtD;;AAEA;AACA,SAAS0E,YAAYA,CAAA,EAAG;EACtB,IAAIC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;EAC/B,IAAIC,gBAAgB,GAAG,IAAI;EAC3B,IAAIC,SAAS,GAAG,IAAIC,cAAc,CAAC;IACjCC,KAAKA,CAACC,UAAU,EAAE;MAChB,IAAI,OAAOrT,MAAM,KAAK,WAAW,EAAE;QACjC;MACF;MACA,IAAIsT,WAAW,GAAIC,KAAK,IAAK;QAC3B,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;UAC7BF,UAAU,CAACG,OAAO,CAACT,OAAO,CAACU,MAAM,CAACF,KAAK,CAAC,CAAC;QAC3C,CAAC,MAAM;UACLF,UAAU,CAACG,OAAO,CAACD,KAAK,CAAC;QAC3B;MACF,CAAC;MACDvT,MAAM,CAAC0T,aAAa,KAAK1T,MAAM,CAAC0T,aAAa,GAAG,EAAE,CAAC;MACnD1T,MAAM,CAAC0T,aAAa,CAAC/O,OAAO,CAAC2O,WAAW,CAAC;MACzCtT,MAAM,CAAC0T,aAAa,CAAC1K,IAAI,GAAIuK,KAAK,IAAK;QACrCD,WAAW,CAACC,KAAK,CAAC;QAClB,OAAO,CAAC;MACV,CAAC;MACDN,gBAAgB,GAAGI,UAAU;IAC/B;EACF,CAAC,CAAC;EACF,IAAI,OAAO/S,QAAQ,KAAK,WAAW,IAAIA,QAAQ,CAACqT,UAAU,KAAK,SAAS,EAAE;IACxErT,QAAQ,CAACsT,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;MAAA,IAAAC,iBAAA;MAClD,CAAAA,iBAAA,GAAAZ,gBAAgB,cAAAY,iBAAA,eAAhBA,iBAAA,CAAkBC,KAAK,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ,CAAC,MAAM;IAAA,IAAAC,kBAAA;IACL,CAAAA,kBAAA,GAAAd,gBAAgB,cAAAc,kBAAA,eAAhBA,kBAAA,CAAkBD,KAAK,CAAC,CAAC;EAC3B;EACA,OAAOZ,SAAS;AAClB;AACA,SACElP,cAAc,EACdxE,eAAe,IAAIxB,cAAc,EACjCuP,iBAAiB,IAAIyG,0BAA0B,EAC/CxO,gBAAgB,IAAIyO,yBAAyB,EAC7CnB,YAAY,IAAIoB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}